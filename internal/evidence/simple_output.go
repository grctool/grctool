// Copyright 2024 GRCTool Authors
// SPDX-License-Identifier: Apache-2.0

package evidence

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/grctool/grctool/internal/domain"
	"github.com/grctool/grctool/internal/logger"
)

// SimpleOutputGenerator handles generation of simplified evidence output
type SimpleOutputGenerator struct {
	dataDir string
	log     logger.Logger
}

// NewSimpleOutputGenerator creates a new simple output generator
func NewSimpleOutputGenerator(dataDir string, log logger.Logger) *SimpleOutputGenerator {
	return &SimpleOutputGenerator{
		dataDir: dataDir,
		log:     log,
	}
}

// CollectionTask represents a discrete evidence collection task
type CollectionTask struct {
	Number      int
	Description string
	Evidence    string
	Snippets    []EvidenceSnippet
}

// EvidenceSnippet represents a snippet of evidence with source metadata
type EvidenceSnippet struct {
	Content         string
	SourceFile      string    // Destination filename
	OriginalPath    string    // Relative path from data directory
	LastModified    time.Time // Last modification date
	GeneratedBy     string    // Tool command if generated
	CollectionDate  time.Time // Collection date if generated
	Section         string    // Section or line reference
}

// SourceFile represents a source file to be copied
type SourceFile struct {
	OriginalPath string    // Absolute path to source
	RelativePath string    // Relative path from data directory
	DestFilename string    // Destination filename
	LastModified time.Time
	GeneratedBy  string // Tool command if generated
}

// GenerateSimpleEvidence generates a simplified evidence file with inline snippets
func (g *SimpleOutputGenerator) GenerateSimpleEvidence(
	task *domain.EvidenceTask,
	window string,
	tasks []CollectionTask,
) (string, error) {
	var sb strings.Builder

	// Header
	sb.WriteString(fmt.Sprintf("# %s: %s\n\n", task.ReferenceID, task.Name))
	sb.WriteString(fmt.Sprintf("**Task Description:** %s\n", task.Description))
	sb.WriteString(fmt.Sprintf("**Collection Date:** %s\n", time.Now().Format("2006-01-02")))
	if window != "" {
		sb.WriteString(fmt.Sprintf("**Collection Window:** %s\n", window))
	}
	sb.WriteString("\n---\n\n")

	// Collection tasks
	for _, ct := range tasks {
		sb.WriteString(fmt.Sprintf("## Collection Task %d: %s\n\n", ct.Number, ct.Description))

		if ct.Evidence != "" {
			sb.WriteString(fmt.Sprintf("**Evidence:** %s\n\n", ct.Evidence))
		}

		// Snippets
		for _, snippet := range ct.Snippets {
			// Source metadata
			sb.WriteString(fmt.Sprintf("**Source:** `%s`  \n", snippet.SourceFile))

			if snippet.GeneratedBy != "" {
				sb.WriteString(fmt.Sprintf("**Generated By:** `%s`  \n", snippet.GeneratedBy))
				sb.WriteString(fmt.Sprintf("**Collection Date:** %s  \n", snippet.CollectionDate.Format("2006-01-02")))
			} else {
				sb.WriteString(fmt.Sprintf("**Original Path:** `%s`  \n", snippet.OriginalPath))
				sb.WriteString(fmt.Sprintf("**Last Modified:** %s  \n", snippet.LastModified.Format("2006-01-02")))
			}

			if snippet.Section != "" {
				sb.WriteString(fmt.Sprintf("**Section:** %s  \n", snippet.Section))
			}
			sb.WriteString("\n")

			// Snippet content as markdown quote
			lines := strings.Split(snippet.Content, "\n")
			for _, line := range lines {
				sb.WriteString("> ")
				sb.WriteString(line)
				sb.WriteString("\n")
			}
			sb.WriteString("\n")
		}

		sb.WriteString("---\n\n")
	}

	return sb.String(), nil
}

// MakeRelativePath converts an absolute path to relative from data directory
func (g *SimpleOutputGenerator) MakeRelativePath(absolutePath string) (string, error) {
	// Clean paths
	absPath := filepath.Clean(absolutePath)
	dataDir := filepath.Clean(g.dataDir)

	// Check if path is within data directory
	if strings.HasPrefix(absPath, dataDir) {
		relPath, err := filepath.Rel(dataDir, absPath)
		if err != nil {
			return "", fmt.Errorf("failed to make relative path: %w", err)
		}
		return relPath, nil
	}

	// If not in data dir, return the absolute path as-is
	return absPath, nil
}

// GetSourceMetadata extracts metadata from a source file
func (g *SimpleOutputGenerator) GetSourceMetadata(filePath string) (*SourceFile, error) {
	info, err := os.Stat(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to stat file %s: %w", filePath, err)
	}

	relPath, err := g.MakeRelativePath(filePath)
	if err != nil {
		g.log.Warn("Failed to make relative path",
			logger.Field{Key: "file", Value: filePath},
			logger.Field{Key: "error", Value: err})
		relPath = filePath
	}

	// Generate destination filename from the source path
	destFilename := filepath.Base(filePath)

	return &SourceFile{
		OriginalPath: filePath,
		RelativePath: relPath,
		DestFilename: destFilename,
		LastModified: info.ModTime(),
	}, nil
}

// CopySourceFilesFlat copies source files to destination directory
func (g *SimpleOutputGenerator) CopySourceFilesFlat(sources []SourceFile, destDir string) error {
	// Ensure destination directory exists
	if err := os.MkdirAll(destDir, 0755); err != nil {
		return fmt.Errorf("failed to create destination directory: %w", err)
	}

	for _, source := range sources {
		destPath := filepath.Join(destDir, source.DestFilename)

		// Read source file
		content, err := os.ReadFile(source.OriginalPath)
		if err != nil {
			g.log.Warn("Failed to read source file",
				logger.Field{Key: "file", Value: source.OriginalPath},
				logger.Field{Key: "error", Value: err})
			continue
		}

		// Write to destination
		if err := os.WriteFile(destPath, content, 0644); err != nil {
			g.log.Warn("Failed to write file",
				logger.Field{Key: "dest", Value: destPath},
				logger.Field{Key: "error", Value: err})
			continue
		}

		g.log.Debug("Copied source file",
			logger.Field{Key: "source", Value: source.RelativePath},
			logger.Field{Key: "dest", Value: source.DestFilename})
	}

	return nil
}

// FormatAsMarkdownQuote formats content as a markdown blockquote
func FormatAsMarkdownQuote(content string) string {
	var sb strings.Builder
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		sb.WriteString("> ")
		sb.WriteString(line)
		sb.WriteString("\n")
	}
	return sb.String()
}

// BreakdownIntoCollectionTasks analyzes task description/guidance and breaks into discrete tasks
// This will be called by Claude during evidence generation
func (g *SimpleOutputGenerator) BreakdownIntoCollectionTasks(task *domain.EvidenceTask) ([]string, error) {
	// This function is a placeholder that will be called by the evidence generation
	// workflow. Claude will use the prompt-assembler tool to analyze the task
	// and break it down into collection tasks.

	// For now, return a default breakdown based on the description
	tasks := []string{
		fmt.Sprintf("Review and document %s", task.Name),
	}

	if task.Description != "" {
		tasks = append(tasks, "Verify requirements from task description")
	}

	if len(task.Controls) > 0 {
		tasks = append(tasks, "Collect evidence for mapped controls")
	}

	return tasks, nil
}

// ExtractRelevantSnippets extracts relevant snippets from evidence content
// This is a helper function that can be used during evidence generation
func (g *SimpleOutputGenerator) ExtractRelevantSnippets(
	content string,
	sourceFile string,
	originalPath string,
	section string,
) EvidenceSnippet {
	return EvidenceSnippet{
		Content:        content,
		SourceFile:     sourceFile,
		OriginalPath:   originalPath,
		Section:        section,
		LastModified:   time.Now(),
		CollectionDate: time.Now(),
	}
}
