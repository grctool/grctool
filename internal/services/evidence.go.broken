package services

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/7thsense/isms/grctool/internal/config"
	"github.com/7thsense/isms/grctool/internal/domain"
	"github.com/7thsense/isms/grctool/internal/logger"
	"github.com/7thsense/isms/grctool/internal/markdown"
	"github.com/7thsense/isms/grctool/internal/models"
	"github.com/7thsense/isms/grctool/internal/orchestrator"
)

// EvidenceService provides evidence-related operations without any Tugboat API dependencies
// This service operates entirely on domain models and should never import tugboat packages
// Uses template-based prompt generation and tool orchestration without external AI APIs
type EvidenceService struct {
	dataService      DataService // Interface to access stored data
	config           *config.Config
	logger           logger.Logger
	toolOrchestrator *orchestrator.ToolOrchestrator
	mdFormatter      *markdown.Formatter
}

// DataService defines the interface for data access operations
// This abstracts away the storage implementation details
type DataService interface {
	// Evidence task operations
	GetEvidenceTask(ctx context.Context, taskID int) (*domain.EvidenceTask, error)
	GetAllEvidenceTasks(ctx context.Context) ([]domain.EvidenceTask, error)
	FilterEvidenceTasks(ctx context.Context, filter domain.EvidenceFilter) ([]domain.EvidenceTask, error)

	// Control operations
	GetControl(ctx context.Context, controlID int) (*domain.Control, error)
	GetAllControls(ctx context.Context) ([]domain.Control, error)

	// Policy operations
	GetPolicy(ctx context.Context, policyID string) (*domain.Policy, error)
	GetAllPolicies(ctx context.Context) ([]domain.Policy, error)

	// Relationship operations
	GetRelationships(ctx context.Context, sourceType, sourceID string) ([]domain.Relationship, error)

	// Evidence record operations
	SaveEvidenceRecord(ctx context.Context, record *domain.EvidenceRecord) error
	GetEvidenceRecords(ctx context.Context, taskID int) ([]domain.EvidenceRecord, error)
}

// NewEvidenceService creates a new evidence service
func NewEvidenceService(dataService DataService, cfg *config.Config, log logger.Logger) (*EvidenceService, error) {
	svc := &EvidenceService{
		dataService: dataService,
		config:      cfg,
		logger:      log,
		mdFormatter: markdown.NewFormatter(markdown.DefaultConfig()),
	}

	// Initialize tool orchestrator (no Claude client needed for prompt-as-data pattern)
	svc.toolOrchestrator = orchestrator.NewToolOrchestrator(cfg, log)

	return svc, nil
}

// EvidenceGenerationRequest represents a request to generate evidence
type EvidenceGenerationRequest struct {
	TaskID      int                    `json:"task_id"`
	Title       string                 `json:"title"`
	Description string                 `json:"description"`
	Format      string                 `json:"format"` // csv, markdown, pdf, etc.
	Tools       []string               `json:"tools"`  // terraform, github, manual, etc.
	Context     map[string]interface{} `json:"context,omitempty"`
}

// EvidenceGenerationResult represents the result of evidence generation
type EvidenceGenerationResult struct {
	Record      *domain.EvidenceRecord `json:"record"`
	Metadata    map[string]interface{} `json:"metadata"`
	Insights    []string               `json:"insights"`
	Suggestions []string               `json:"suggestions"`
}

// EvidenceAnalysisResult represents the result of evidence task analysis
type EvidenceAnalysisResult struct {
	Task              *domain.EvidenceTaskDetails `json:"task"`
	RelatedControls   []domain.Control            `json:"related_controls"`
	RelatedPolicies   []domain.Policy             `json:"related_policies"`
	Relationships     []domain.Relationship       `json:"relationships"`
	Recommendations   []string                    `json:"recommendations"`
	RequiredEvidence  []string                    `json:"required_evidence"`
	SuggestedTools    []string                    `json:"suggested_tools"`
	ComplianceContext map[string]interface{}      `json:"compliance_context"`
}

// AnalyzeEvidenceTask performs comprehensive analysis of an evidence task
// This function maps relationships to controls and policies, generates insights,
// and provides recommendations for evidence collection
func (s *EvidenceService) AnalyzeEvidenceTask(ctx context.Context, taskID int) (*EvidenceAnalysisResult, error) {
	// Get the evidence task
	task, err := s.dataService.GetEvidenceTask(ctx, taskID)
	if err != nil {
		return nil, fmt.Errorf("failed to get evidence task: %w", err)
	}

	result := &EvidenceAnalysisResult{
		Task:              task,
		RelatedControls:   []domain.Control{},
		RelatedPolicies:   []domain.Policy{},
		Relationships:     []domain.Relationship{},
		Recommendations:   []string{},
		RequiredEvidence:  []string{},
		SuggestedTools:    []string{},
		ComplianceContext: make(map[string]interface{}),
	}

	// Analyze control relationships
	if err := s.analyzeControlRelationships(ctx, task, result); err != nil {
		return nil, fmt.Errorf("failed to analyze control relationships: %w", err)
	}

	// Analyze policy relationships
	if err := s.analyzePolicyRelationships(ctx, task, result); err != nil {
		return nil, fmt.Errorf("failed to analyze policy relationships: %w", err)
	}

	// Generate recommendations based on task characteristics
	s.generateRecommendations(task, result)

	// Suggest appropriate tools based on task type and framework
	s.suggestTools(task, result)

	// Build compliance context
	s.buildComplianceContext(task, result)

	return result, nil
}

// // GenerateEvidence coordinates evidence generation using AI and tools
func (s *EvidenceService) // GenerateEvidence(ctx context.Context, req *EvidenceGenerationRequest) (*EvidenceGenerationResult, error) {
	// First, analyze the task to get context
	analysis, err := s.AnalyzeEvidenceTask(ctx, req.TaskID)
	if err != nil {
		return nil, fmt.Errorf("failed to analyze evidence task: %w", err)
	}

	// Create evidence record
	record := &domain.EvidenceRecord{
		ID:          fmt.Sprintf("evidence_%d_%d", req.TaskID, time.Now().Unix()),
		TaskID:      req.TaskID,
		Title:       req.Title,
		Description: req.Description,
		Format:      req.Format,
		CollectedAt: time.Now(),
		CollectedBy: "grctool-ai", // Could be made configurable
		Metadata:    req.Context,
	}

	// Determine the source based on tools used
	if len(req.Tools) > 0 {
		record.Source = req.Tools[0] // Primary tool
		if len(req.Tools) > 1 {
			// Store additional tools in metadata
			if record.Metadata == nil {
				record.Metadata = make(map[string]interface{})
			}
			record.Metadata["additional_tools"] = req.Tools[1:]
		}
	} else {
		record.Source = "manual"
	}

	// Generate content placeholder (this would integrate with AI service)
	content, err := s.generateEvidenceContent(ctx, analysis, req)
	if err != nil {
		return nil, fmt.Errorf("failed to generate evidence content: %w", err)
	}
	record.Content = content

	// Save the evidence record
	if err := s.dataService.SaveEvidenceRecord(ctx, record); err != nil {
		return nil, fmt.Errorf("failed to save evidence record: %w", err)
	}

	result := &EvidenceGenerationResult{
		Record:      record,
		Metadata:    analysis.ComplianceContext,
		Insights:    analysis.Recommendations,
		Suggestions: analysis.SuggestedTools,
	}

	return result, nil
}

// ListEvidenceTasks returns filtered evidence tasks
func (s *EvidenceService) ListEvidenceTasks(ctx context.Context, filter domain.EvidenceFilter) ([]domain.EvidenceTask, error) {
	return s.dataService.FilterEvidenceTasks(ctx, filter)
}

// GetEvidenceTaskSummary generates a summary of evidence tasks
func (s *EvidenceService) GetEvidenceTaskSummary(ctx context.Context) (*domain.EvidenceTaskSummary, error) {
	tasks, err := s.dataService.GetAllEvidenceTasks(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get all evidence tasks: %w", err)
	}

	summary := &domain.EvidenceTaskSummary{
		Total:      len(tasks),
		ByStatus:   make(map[string]int),
		ByPriority: make(map[string]int),
		LastSync:   time.Now(), // Would be provided by data service
	}

	for _, task := range tasks {
		// Count by status
		if task.Status != "" {
			summary.ByStatus[task.Status]++
		}

		// Count by priority
		if task.Priority != "" {
			summary.ByPriority[task.Priority]++
		}

		// Count overdue and due soon tasks
		if task.NextDue != nil {
			now := time.Now()
			if task.NextDue.Before(now) {
				summary.Overdue++
			} else if task.NextDue.Before(now.AddDate(0, 0, 7)) {
				summary.DueSoon++
			}
		}
	}

	return summary, nil
}

// ReviewEvidence provides analysis and feedback on generated evidence
func (s *EvidenceService) ReviewEvidence(ctx context.Context, recordID string, showReasoning bool) (map[string]interface{}, error) {
	// This would implement evidence review logic
	review := map[string]interface{}{
		"record_id":    recordID,
		"completeness": "high",
		"accuracy":     "verified",
		"compliance":   "meets_requirements",
		"suggestions":  []string{"Consider adding implementation timeline", "Include risk assessment details"},
		"next_actions": []string{"Submit for approval", "Schedule follow-up review"},
	}

	if showReasoning {
		review["reasoning"] = map[string]interface{}{
			"analysis_method":  "ai_assisted_compliance_check",
			"criteria_checked": []string{"SOC2_requirements", "evidence_completeness", "formatting_standards"},
			"confidence_score": 0.95,
		}
	}

	return review, nil
}

// Helper methods for analysis

func (s *EvidenceService) analyzeControlRelationships(ctx context.Context, task *domain.EvidenceTaskDetails, result *EvidenceAnalysisResult) error {
	// Map evidence task to related controls from task.Controls field
	for _, controlID := range task.Controls {
		// Try to convert string control ID to int for lookup
		if controlIDInt, err := strconv.Atoi(controlID); err == nil {
			if control, err := s.dataService.GetControl(ctx, controlIDInt); err == nil && control != nil {
				result.RelatedControls = append(result.RelatedControls, *control)

				// Create relationship record
				rel := domain.Relationship{
					SourceType: "evidence_task",
					SourceID:   fmt.Sprintf("%d", task.ID),
					TargetType: "control",
					TargetID:   controlID,
					Type:       "verifies",
				}
				result.Relationships = append(result.Relationships, rel)
			}
		}
	}

	// If no controls found directly, try to find related controls by keyword matching
	if len(result.RelatedControls) == 0 {
		allControls, err := s.dataService.GetAllControls(ctx)
		if err != nil {
			return err
		}

		taskText := strings.ToLower(task.Name + " " + task.Description)

		// Keywords for control matching based on evidence task content
		controlKeywords := []string{
			"access control", "access", "user", "authentication", "authorization",
			"registration", "de-registration", "onboarding", "offboarding",
			"employee", "personnel", "contractor", "identity", "account",
			"asset", "inventory", "configuration", "system", "infrastructure",
			"vulnerability", "security", "incident", "backup", "network",
		}

		for _, control := range allControls {
			controlText := strings.ToLower(control.Name + " " + control.Description)

			// Check for keyword matches between task and control
			for _, keyword := range controlKeywords {
				if strings.Contains(taskText, keyword) && strings.Contains(controlText, keyword) {
					result.RelatedControls = append(result.RelatedControls, control)

					// Create relationship record
					rel := domain.Relationship{
						SourceType: "evidence_task",
						SourceID:   fmt.Sprintf("%d", task.ID),
						TargetType: "control",
						TargetID:   fmt.Sprintf("%d", control.ID),
						Type:       "supports",
					}
					result.Relationships = append(result.Relationships, rel)
					break // Only match once per control
				}
			}
		}
	}

	return nil
}

func (s *EvidenceService) analyzePolicyRelationships(ctx context.Context, task *domain.EvidenceTaskDetails, result *EvidenceAnalysisResult) error {
	// Get all policies and find ones that relate to this task
	policies, err := s.dataService.GetAllPolicies(ctx)
	if err != nil {
		return err
	}

	// Enhanced policy matching logic with focus on access control relevance
	for _, policy := range policies {
		isRelated := false

		// 1. Match by framework if both have frameworks
		if task.Framework != "" && policy.Framework != "" && policy.Framework == task.Framework {
			isRelated = true
		}

		// 2. Enhanced keyword matching for access control tasks
		taskText := strings.ToLower(task.Name + " " + task.Description)
		policyText := strings.ToLower(policy.Name + " " + policy.Description)

		// Prioritize access control related policies
		accessControlKeywords := []string{
			"access control", "access", "registration", "de-registration", "user",
			"authentication", "authorization", "identity", "password", "personnel",
		}

		supportingKeywords := []string{
			"information security", "incident management", "vendor management",
			"change management", "vulnerability", "management philosophy",
		}

		// Check for direct access control relevance
		for _, keyword := range accessControlKeywords {
			if strings.Contains(taskText, keyword) && strings.Contains(policyText, keyword) {
				isRelated = true
				break
			}
		}

		// Check for supporting policy relevance (but limit to key policies)
		if !isRelated && strings.Contains(taskText, "access") {
			for _, keyword := range supportingKeywords {
				if strings.Contains(policyText, keyword) {
					isRelated = true
					break
				}
			}
		}

		if isRelated {
			result.RelatedPolicies = append(result.RelatedPolicies, policy)

			// Create relationship record
			rel := domain.Relationship{
				SourceType: "evidence_task",
				SourceID:   fmt.Sprintf("%d", task.ID),
				TargetType: "policy",
				TargetID:   policy.ID,
				Type:       "implements",
			}
			result.Relationships = append(result.Relationships, rel)
		}
	}

	return nil
}

func (s *EvidenceService) generateRecommendations(task *domain.EvidenceTaskDetails, result *EvidenceAnalysisResult) {
	recommendations := []string{
		"Collect evidence for the " + task.CollectionInterval + " period",
		"Ensure evidence demonstrates compliance with " + task.Framework + " requirements",
	}

	if task.Sensitive {
		recommendations = append(recommendations, "Handle sensitive data according to data protection policies")
	}

	if task.AdHoc {
		recommendations = append(recommendations, "This is an ad-hoc task - consider if it should be added to regular collection schedule")
	}

	result.Recommendations = recommendations
}

func (s *EvidenceService) suggestTools(task *domain.EvidenceTaskDetails, result *EvidenceAnalysisResult) {
	tools := []string{}

	// Suggest tools based on framework
	switch task.Framework {
	case "SOC2":
		tools = append(tools, "terraform", "github")
		if len(result.RelatedControls) > 0 {
			tools = append(tools, "aws_config")
		}
	case "ISO27001":
		tools = append(tools, "terraform", "documentation")
	}

	// Suggest based on task name/description
	taskText := task.Name + " " + task.Description
	if contains(taskText, "access") || contains(taskText, "identity") {
		tools = append(tools, "aws_iam")
	}
	if contains(taskText, "network") || contains(taskText, "firewall") {
		tools = append(tools, "network_scanner")
	}
	if contains(taskText, "backup") || contains(taskText, "recovery") {
		tools = append(tools, "backup_verification")
	}

	result.SuggestedTools = tools
}

func (s *EvidenceService) buildComplianceContext(task *domain.EvidenceTaskDetails, result *EvidenceAnalysisResult) {
	context := map[string]interface{}{
		"framework":           task.Framework,
		"collection_interval": task.CollectionInterval,
		"priority":            task.Priority,
		"control_count":       len(result.RelatedControls),
		"policy_count":        len(result.RelatedPolicies),
		"due_date":            task.NextDue,
		"is_overdue":          task.NextDue != nil && task.NextDue.Before(time.Now()),
	}

	if task.OrgScope != nil {
		context["org_scope"] = map[string]interface{}{
			"id":          task.OrgScope.ID,
			"name":        task.OrgScope.Name,
			"type":        task.OrgScope.Type,
			"description": task.OrgScope.Description,
		}
	}

	result.ComplianceContext = context
}

func (s *EvidenceService) generateEvidenceContent(ctx context.Context, analysis *EvidenceAnalysisResult, req *EvidenceGenerationRequest) (string, error) {
	// Use template-based generation (no Claude client needed)
	if s.toolOrchestrator == nil {
		// Fallback to simple generation if orchestrator is not configured
		return s.generateSimpleEvidenceContent(analysis, req), nil
	}

	// Convert domain models to API models for Claude
	// Need to convert domain.EvidenceTaskDetails to models.EvidenceTaskDetails
	var lastCollectedStr *string
	if analysis.Task.LastCollected != nil {
		str := analysis.Task.LastCollected.Format(time.RFC3339)
		lastCollectedStr = &str
	}

	taskModel := models.EvidenceTaskDetails{
		EvidenceTask: models.EvidenceTask{
			ID:                 analysis.Task.ID,
			Name:               analysis.Task.Name,
			Description:        analysis.Task.Description,
			Guidance:           analysis.Task.Guidance,
			CollectionInterval: analysis.Task.CollectionInterval,
			Priority:           analysis.Task.Priority,
			Status:             analysis.Task.Status,
			Completed:          analysis.Task.Completed,
			LastCollected:      lastCollectedStr,
			DueDaysBefore:      analysis.Task.DueDaysBefore,
			AdHoc:              analysis.Task.AdHoc,
			Sensitive:          analysis.Task.Sensitive,
			CreatedAt:          analysis.Task.CreatedAt,
			UpdatedAt:          analysis.Task.UpdatedAt,
		},
	}
	evidenceContext := &models.EvidenceContext{
		Task:             taskModel,
		Controls:         s.convertControls(analysis.RelatedControls),
		Policies:         s.convertPolicies(analysis.RelatedPolicies),
		FrameworkReqs:    s.extractFrameworkRequirements(analysis),
		SecurityMappings: s.getSecurityMappings(),
	}

	// Generate summaries if summarization service is available
	if // s.summarizationService != nil {
		s.logger.Info("Generating AI summaries for controls and policies")

		// Initialize summary maps
		evidenceContext.ControlSummaries = make(map[int]models.AIControlSummary)
		evidenceContext.PolicySummaries = make(map[string]models.AIPolicySummary)

		// Generate control summaries
		for _, control := range evidenceContext.Controls {
			summary, err := // s.summarizationService.SummarizeControlForTask(ctx, &taskModel, &control)
			if err != nil {
				// Log error and fail the entire generation - no fallbacks
				s.logger.Error("Failed to generate control summary",
					logger.Field{Key: "control_id", Value: control.ID},
					logger.Field{Key: "error", Value: err},
				)
				return "", fmt.Errorf("failed to generate summary for control %d: %w", control.ID, err)
			}
			// Store summary by control ID
			evidenceContext.ControlSummaries[control.ID] = *summary
		}

		// Generate policy summaries
		for _, policy := range evidenceContext.Policies {
			summary, err := // s.summarizationService.SummarizePolicyForTask(ctx, &taskModel, &policy)
			if err != nil {
				// Log error and fail the entire generation - no fallbacks
				s.logger.Error("Failed to generate policy summary",
					logger.Field{Key: "policy_id", Value: policy.ID},
					logger.Field{Key: "error", Value: err},
				)
				return "", fmt.Errorf("failed to generate summary for policy %s: %w", policy.ID, err)
			}
			// Store summary by policy ID
			evidenceContext.PolicySummaries[policy.ID.String()] = *summary
		}

		s.logger.Info("Generated summaries",
			logger.Field{Key: "control_summaries", Value: len(evidenceContext.ControlSummaries)},
			logger.Field{Key: "policy_summaries", Value: len(evidenceContext.PolicySummaries)},
		)
	}

	// Create prompt text
	promptText, err := // s.claudeClient.CreateEvidencePrompt(evidenceContext, req.Format)
	if err != nil {
		return "", fmt.Errorf("failed to create evidence prompt: %w", err)
	}

	// Create prompt
	prompt := &models.EvidencePrompt{
		TaskID:         req.TaskID,
		GeneratedAt:    time.Now(),
		Context:        *evidenceContext,
		PromptText:     promptText,
		ToolsAvailable: req.Tools,
	}

	// Save prompt if configured
	if s.config.Evidence.Generation.PromptDir != "" {
		if err := s.savePrompt(prompt); err != nil {
			s.logger.Warn("Failed to save prompt", logger.Field{Key: "error", Value: err})
		}
	}

	// Generate evidence using orchestrator
	generatedEvidence, err := s.toolOrchestrator.// GenerateEvidence(ctx, prompt)
	if err != nil {
		return "", fmt.Errorf("failed to generate evidence with AI: %w", err)
	}

	// Save generated evidence if configured
	if s.config.Evidence.Generation.OutputDir != "" {
		if err := s.saveGeneratedEvidence(generatedEvidence); err != nil {
			s.logger.Warn("Failed to save generated evidence", logger.Field{Key: "error", Value: err})
		}
	}

	return generatedEvidence.EvidenceContent, nil
}

// generateSimpleEvidenceContent generates basic evidence content without AI
func (s *EvidenceService) generateSimpleEvidenceContent(analysis *EvidenceAnalysisResult, req *EvidenceGenerationRequest) string {
	content := fmt.Sprintf("# Evidence for Task: %s\n\n", analysis.Task.Name)
	content += fmt.Sprintf("**Framework:** %s\n", analysis.Task.Framework)
	content += fmt.Sprintf("**Priority:** %s\n", analysis.Task.Priority)
	content += fmt.Sprintf("**Collection Date:** %s\n\n", time.Now().Format("2006-01-02"))

	content += "## Task Description\n"
	content += analysis.Task.Description + "\n\n"

	if analysis.Task.Guidance != "" {
		content += "## Guidance\n"
		content += analysis.Task.Guidance + "\n\n"
	}

	if len(analysis.RelatedControls) > 0 {
		content += "## Related Controls\n"
		for _, control := range analysis.RelatedControls {
			content += fmt.Sprintf("- **%s**: %s\n", control.Name, control.Description)
		}
		content += "\n"
	}

	if len(analysis.RelatedPolicies) > 0 {
		content += "## Related Policies\n"
		for _, policy := range analysis.RelatedPolicies {
			content += fmt.Sprintf("- **%s**: Policy\n", policy.Name)
		}
		content += "\n"
	}

	content += "## Evidence Collection\n"
	if len(req.Tools) > 0 {
		content += "Evidence collected using tools: " + strings.Join(req.Tools, ", ") + "\n\n"
	} else {
		content += "Manual evidence collection required.\n\n"
	}

	content += "## Compliance Status\n"
	content += "This evidence demonstrates compliance with the specified requirements.\n\n"

	if len(analysis.Recommendations) > 0 {
		content += "## Recommendations\n"
		for _, rec := range analysis.Recommendations {
			content += fmt.Sprintf("- %s\n", rec)
		}
		content += "\n"
	}

	content += "---\n"
	content += "Generated by grctool evidence collection system\n"

	return content
}

// Helper methods for conversion and saving

func (s *EvidenceService) convertControls(controls []domain.Control) []models.Control {
	var result []models.Control
	for _, c := range controls {
		// Convert domain.Control to models.Control
		modelControl := models.Control{
			ID:                c.ID,
			Name:              c.Name,
			Category:          c.Category,
			Status:            c.Status,
			Body:              c.Description,
			IsAutoImplemented: false, // Default, could be derived
			OrgScope:          nil,   // Would need conversion
			FrameworkCodes:    []models.FrameworkCode{},
		}

		// Add framework codes if available
		if c.Framework != "" {
			modelControl.FrameworkCodes = append(modelControl.FrameworkCodes, models.FrameworkCode{
				Code:          fmt.Sprintf("%d", c.ID),
				FrameworkName: c.Framework,
			})
		}

		result = append(result, modelControl)
	}
	return result
}

func (s *EvidenceService) convertPolicies(policies []domain.Policy) []models.Policy {
	var result []models.Policy
	for _, p := range policies {
		// Convert domain.Policy to models.Policy
		modelPolicy := models.Policy{
			ID:          models.IntOrString(p.ID),
			Name:        p.Name,
			Description: p.Description,
			Status:      p.Status,
			Framework:   p.Framework,
			Controls:    []models.Control{}, // Would need to fetch if needed
		}
		result = append(result, modelPolicy)
	}
	return result
}

func (s *EvidenceService) extractFrameworkRequirements(analysis *EvidenceAnalysisResult) []string {
	var reqs []string
	seen := make(map[string]bool)

	// Extract from controls
	for _, control := range analysis.RelatedControls {
		if control.Framework != "" && !seen[control.Framework] {
			reqs = append(reqs, control.Framework)
			seen[control.Framework] = true
		}
	}

	// Add task framework
	if analysis.Task.Framework != "" && !seen[analysis.Task.Framework] {
		reqs = append(reqs, analysis.Task.Framework)
	}

	return reqs
}

func (s *EvidenceService) getSecurityMappings() models.SecurityMappings {
	// Convert config mappings to model mappings
	mappings := make(map[string]models.SecurityControlMapping)
	for k, v := range s.config.Evidence.SecurityControls.SOC2 {
		mappings[k] = models.SecurityControlMapping{
			TerraformResources: v.TerraformResources,
			Description:        v.Description,
			Requirements:       v.Requirements,
		}
	}
	return models.SecurityMappings{
		SOC2: mappings,
	}
}

func (s *EvidenceService) savePrompt(prompt *models.EvidencePrompt) error {
	promptDir := s.config.Evidence.Generation.PromptDir
	if err := os.MkdirAll(promptDir, 0755); err != nil {
		return fmt.Errorf("failed to create prompt directory: %w", err)
	}

	filename := fmt.Sprintf("prompt_task_%d_%s.md", prompt.TaskID, prompt.GeneratedAt.Format("20060102_150405"))
	filePath := filepath.Join(promptDir, filename)
	prompt.FilePath = filePath

	// Format the prompt text before saving
	formattedPrompt := s.mdFormatter.FormatPrompt(prompt.PromptText)
	return os.WriteFile(filePath, []byte(formattedPrompt), 0644)
}

func (s *EvidenceService) saveGeneratedEvidence(evidence *models.GeneratedEvidence) error {
	outputDir := s.config.Evidence.Generation.OutputDir
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("failed to create output directory: %w", err)
	}

	// Create task-specific directory using task ID (e.g., ET87)
	taskDir := filepath.Join(outputDir, fmt.Sprintf("ET%d", evidence.TaskID))
	if err := os.MkdirAll(taskDir, 0755); err != nil {
		return fmt.Errorf("failed to create task directory: %w", err)
	}

	// Save main evidence content
	ext := ".md"
	if evidence.EvidenceFormat == "csv" {
		ext = ".csv"
	}
	filename := fmt.Sprintf("evidence_%s%s", evidence.GeneratedAt.Format("20060102_150405"), ext)
	filePath := filepath.Join(taskDir, filename)

	// Format markdown evidence content before saving
	content := evidence.EvidenceContent
	if evidence.EvidenceFormat != "csv" {
		content = s.mdFormatter.FormatDocument(content)
	}
	if err := os.WriteFile(filePath, []byte(content), 0644); err != nil {
		return fmt.Errorf("failed to write evidence file: %w", err)
	}

	// Extract and save terraform snippets as individual files
	if evidence.SourcesUsed != nil {
		for _, source := range evidence.SourcesUsed {
			if source.Type == "terraform" && source.Content != "" {
				// Extract terraform resources from the source content
				if err := s.saveTerraformSnippets(taskDir, source.Content); err != nil {
					s.logger.Warn("Failed to save terraform snippets", logger.Field{Key: "error", Value: err})
				}
			}
		}
	}

	// Save reasoning if available
	if evidence.Reasoning != "" && s.config.Evidence.Generation.IncludeReasoning {
		reasoningFile := filepath.Join(taskDir, fmt.Sprintf("reasoning_%s.md", evidence.GeneratedAt.Format("20060102_150405")))
		// Format the reasoning markdown before saving
		formattedReasoning := s.mdFormatter.FormatDocument(evidence.Reasoning)
		if err := os.WriteFile(reasoningFile, []byte(formattedReasoning), 0644); err != nil {
			s.logger.Warn("Failed to save reasoning", logger.Field{Key: "error", Value: err})
		}
	}

	evidence.OutputDirectory = taskDir
	return nil
}

// saveTerraformSnippets extracts terraform resources from tool output and saves them as individual files
func (s *EvidenceService) saveTerraformSnippets(taskDir string, toolOutput string) error {
	// Create terraform snippets subdirectory
	terraformDir := filepath.Join(taskDir, "terraform_snippets")
	if err := os.MkdirAll(terraformDir, 0755); err != nil {
		return fmt.Errorf("failed to create terraform snippets directory: %w", err)
	}

	// Parse the tool output to extract terraform resources
	// The output contains resource blocks that we need to extract
	resourcePattern := regexp.MustCompile(`(?ms)resource\s+"([^"]+)"\s+"([^"]+)"\s*\{.*?\n\}`)
	matches := resourcePattern.FindAllStringSubmatch(toolOutput, -1)

	for i, match := range matches {
		if len(match) >= 3 {
			resourceType := match[1]
			resourceName := match[2]
			resourceContent := match[0]

			// Create filename based on resource type and name
			filename := fmt.Sprintf("%02d_%s_%s.tf", i+1, resourceType, resourceName)
			filePath := filepath.Join(terraformDir, filename)

			// Write the terraform snippet to file
			if err := os.WriteFile(filePath, []byte(resourceContent), 0644); err != nil {
				s.logger.Warn("Failed to save terraform snippet",
					logger.Field{Key: "file", Value: filename},
					logger.Field{Key: "error", Value: err})
				continue
			}

			s.logger.Debug("Saved terraform snippet", logger.Field{Key: "file", Value: filename})
		}
	}

	// Also save a summary file with all resources
	summaryPath := filepath.Join(terraformDir, "00_summary.md")
	summary := fmt.Sprintf("# Terraform Resources Summary\n\nTotal resources found: %d\n\n", len(matches))
	for i, match := range matches {
		if len(match) >= 3 {
			summary += fmt.Sprintf("- `%s.%s` (file: %02d_%s_%s.tf)\n", match[1], match[2], i+1, match[1], match[2])
		}
	}

	// Format the summary before saving
	formattedSummary := s.mdFormatter.FormatDocument(summary)
	return os.WriteFile(summaryPath, []byte(formattedSummary), 0644)
}

// Helper function
func contains(text, substr string) bool {
	return len(text) >= len(substr) && (text == substr ||
		(len(text) > len(substr) &&
			(text[:len(substr)] == substr ||
				text[len(text)-len(substr):] == substr ||
				findSubstring(text, substr))))
}

func findSubstring(text, substr string) bool {
	for i := 0; i <= len(text)-len(substr); i++ {
		if text[i:i+len(substr)] == substr {
			return true
		}
	}
	return false
}
